<?php
/**
 * TransactionView
 *
 * PHP version 5
 *
 * @category Class
 * @package  Cyclos\Api
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Cyclos 4.12.6 API
 *
 * The Cyclos REST API is described using OpenAPI 3.0. The descriptor for the api can be downloaded in both [YAML](http://kb1.cyclos-dev.info/api/cyclos-openapi.yaml) or [JSON](http://kb1.cyclos-dev.info/api/cyclos-openapi.json) formats. These files can be used in tools that support the OpenAPI specification, such as the [Swagger Generator](https://generator.swagger.io/).  In the API, whenever some data is referenced, for example, a group, or payment type, either id or internal name can be used. When an user is to be referenced, the special word 'self' (sans quotes) always refers to the currently authenticated user, and any identification method (login name, e-mail, mobile phone, account number or custom field) that can be used on keywords search (as configured in the products) can also be used to identify users. Some specific data types have other identification fields, like accounts can have a number and payments can have a transaction number. This all depends on the current configuration.  Most of the operations that return data allow selecting which fields to include in the response. This is useful for reducing the data to be download over the network. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  For details of the deprecated elements (operations and model) please visit the [deprecation notes page](https://documentation.cyclos.org/4.12.6/api-deprecation.html) for this version.
 *
 * OpenAPI spec version: 4.12.6
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.19
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Cyclos\Api\Model;
use \Cyclos\Api\ObjectSerializer;

/**
 * TransactionView Class Doc Comment
 *
 * @category Class
 * @description Details about a transaction
 * @package  Cyclos\Api
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class TransactionView extends Transaction 
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'TransactionView';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'channel' => '',
'access_client' => '',
'by' => '',
'received_by' => '',
'received' => 'bool',
'custom_values' => '\Cyclos\Api\Model\CustomFieldValue[]',
'confirmation_password_input' => '',
'authorization_level_data' => '',
'authorization_permissions' => '',
'authorizations' => '\Cyclos\Api\Model\TransactionAuthorization[]',
'transfer' => '',
'scheduled_payment_permissions' => '',
'due_amount' => 'float',
'installments' => '\Cyclos\Api\Model\ScheduledPaymentInstallmentView[]',
'recurring_payment_permissions' => '',
'next_occurrence_date' => '\DateTime',
'occurrence_interval' => '',
'occurrences_count' => 'int',
'occurrences' => '\Cyclos\Api\Model\RecurringPaymentOccurrenceView[]',
'original_transfer' => '',
'chargeback_transfer' => '',
'payment_request_permissions' => '',
'comments' => 'string',
'expiration_date' => '\DateTime',
'change_expiration_date_comments' => 'string',
'process_date' => '\DateTime',
'transaction' => '',
'sms_code' => 'string',
'scheduled' => 'bool',
'scheduling' => '',
'installments_count' => 'int',
'first_installment_is_immediate' => 'bool',
'first_occurrence_is_immediate' => 'bool',
'to_principal_type' => '',
'to_principal_value' => 'string',
'payer_principal' => 'string',
'cancel_url' => 'string',
'success_url' => 'string',
'preview' => '',
'users_which_can_add_to_contacts' => '\Cyclos\Api\Model\TransactionSubjectsEnum',
'users_which_can_view_profile' => '\Cyclos\Api\Model\TransactionSubjectsEnum',
'authorization_type' => '\Cyclos\Api\Model\TransactionAuthorizationTypeEnum',
'scheduled_payment_status' => '\Cyclos\Api\Model\ScheduledPaymentStatusEnum',
'recurring_payment_status' => '\Cyclos\Api\Model\RecurringPaymentStatusEnum',
'payment_request_status' => '\Cyclos\Api\Model\PaymentRequestStatusEnum',
'external_payment_status' => '\Cyclos\Api\Model\ExternalPaymentStatusEnum',
'ticket_status' => '\Cyclos\Api\Model\TicketStatusEnum'    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'channel' => null,
'access_client' => null,
'by' => null,
'received_by' => null,
'received' => null,
'custom_values' => null,
'confirmation_password_input' => null,
'authorization_level_data' => null,
'authorization_permissions' => null,
'authorizations' => null,
'transfer' => null,
'scheduled_payment_permissions' => null,
'due_amount' => 'number',
'installments' => null,
'recurring_payment_permissions' => null,
'next_occurrence_date' => 'date-time',
'occurrence_interval' => null,
'occurrences_count' => null,
'occurrences' => null,
'original_transfer' => null,
'chargeback_transfer' => null,
'payment_request_permissions' => null,
'comments' => null,
'expiration_date' => 'date-time',
'change_expiration_date_comments' => null,
'process_date' => 'date-time',
'transaction' => null,
'sms_code' => null,
'scheduled' => null,
'scheduling' => null,
'installments_count' => null,
'first_installment_is_immediate' => null,
'first_occurrence_is_immediate' => null,
'to_principal_type' => null,
'to_principal_value' => null,
'payer_principal' => null,
'cancel_url' => null,
'success_url' => null,
'preview' => null,
'users_which_can_add_to_contacts' => null,
'users_which_can_view_profile' => null,
'authorization_type' => null,
'scheduled_payment_status' => null,
'recurring_payment_status' => null,
'payment_request_status' => null,
'external_payment_status' => null,
'ticket_status' => null    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes + parent::swaggerTypes();
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats + parent::swaggerFormats();
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'channel' => 'channel',
'access_client' => 'accessClient',
'by' => 'by',
'received_by' => 'receivedBy',
'received' => 'received',
'custom_values' => 'customValues',
'confirmation_password_input' => 'confirmationPasswordInput',
'authorization_level_data' => 'authorizationLevelData',
'authorization_permissions' => 'authorizationPermissions',
'authorizations' => 'authorizations',
'transfer' => 'transfer',
'scheduled_payment_permissions' => 'scheduledPaymentPermissions',
'due_amount' => 'dueAmount',
'installments' => 'installments',
'recurring_payment_permissions' => 'recurringPaymentPermissions',
'next_occurrence_date' => 'nextOccurrenceDate',
'occurrence_interval' => 'occurrenceInterval',
'occurrences_count' => 'occurrencesCount',
'occurrences' => 'occurrences',
'original_transfer' => 'originalTransfer',
'chargeback_transfer' => 'chargebackTransfer',
'payment_request_permissions' => 'paymentRequestPermissions',
'comments' => 'comments',
'expiration_date' => 'expirationDate',
'change_expiration_date_comments' => 'changeExpirationDateComments',
'process_date' => 'processDate',
'transaction' => 'transaction',
'sms_code' => 'smsCode',
'scheduled' => 'scheduled',
'scheduling' => 'scheduling',
'installments_count' => 'installmentsCount',
'first_installment_is_immediate' => 'firstInstallmentIsImmediate',
'first_occurrence_is_immediate' => 'firstOccurrenceIsImmediate',
'to_principal_type' => 'toPrincipalType',
'to_principal_value' => 'toPrincipalValue',
'payer_principal' => 'payerPrincipal',
'cancel_url' => 'cancelUrl',
'success_url' => 'successUrl',
'preview' => 'preview',
'users_which_can_add_to_contacts' => 'usersWhichCanAddToContacts',
'users_which_can_view_profile' => 'usersWhichCanViewProfile',
'authorization_type' => 'authorizationType',
'scheduled_payment_status' => 'scheduledPaymentStatus',
'recurring_payment_status' => 'recurringPaymentStatus',
'payment_request_status' => 'paymentRequestStatus',
'external_payment_status' => 'externalPaymentStatus',
'ticket_status' => 'ticketStatus'    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'channel' => 'setChannel',
'access_client' => 'setAccessClient',
'by' => 'setBy',
'received_by' => 'setReceivedBy',
'received' => 'setReceived',
'custom_values' => 'setCustomValues',
'confirmation_password_input' => 'setConfirmationPasswordInput',
'authorization_level_data' => 'setAuthorizationLevelData',
'authorization_permissions' => 'setAuthorizationPermissions',
'authorizations' => 'setAuthorizations',
'transfer' => 'setTransfer',
'scheduled_payment_permissions' => 'setScheduledPaymentPermissions',
'due_amount' => 'setDueAmount',
'installments' => 'setInstallments',
'recurring_payment_permissions' => 'setRecurringPaymentPermissions',
'next_occurrence_date' => 'setNextOccurrenceDate',
'occurrence_interval' => 'setOccurrenceInterval',
'occurrences_count' => 'setOccurrencesCount',
'occurrences' => 'setOccurrences',
'original_transfer' => 'setOriginalTransfer',
'chargeback_transfer' => 'setChargebackTransfer',
'payment_request_permissions' => 'setPaymentRequestPermissions',
'comments' => 'setComments',
'expiration_date' => 'setExpirationDate',
'change_expiration_date_comments' => 'setChangeExpirationDateComments',
'process_date' => 'setProcessDate',
'transaction' => 'setTransaction',
'sms_code' => 'setSmsCode',
'scheduled' => 'setScheduled',
'scheduling' => 'setScheduling',
'installments_count' => 'setInstallmentsCount',
'first_installment_is_immediate' => 'setFirstInstallmentIsImmediate',
'first_occurrence_is_immediate' => 'setFirstOccurrenceIsImmediate',
'to_principal_type' => 'setToPrincipalType',
'to_principal_value' => 'setToPrincipalValue',
'payer_principal' => 'setPayerPrincipal',
'cancel_url' => 'setCancelUrl',
'success_url' => 'setSuccessUrl',
'preview' => 'setPreview',
'users_which_can_add_to_contacts' => 'setUsersWhichCanAddToContacts',
'users_which_can_view_profile' => 'setUsersWhichCanViewProfile',
'authorization_type' => 'setAuthorizationType',
'scheduled_payment_status' => 'setScheduledPaymentStatus',
'recurring_payment_status' => 'setRecurringPaymentStatus',
'payment_request_status' => 'setPaymentRequestStatus',
'external_payment_status' => 'setExternalPaymentStatus',
'ticket_status' => 'setTicketStatus'    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'channel' => 'getChannel',
'access_client' => 'getAccessClient',
'by' => 'getBy',
'received_by' => 'getReceivedBy',
'received' => 'getReceived',
'custom_values' => 'getCustomValues',
'confirmation_password_input' => 'getConfirmationPasswordInput',
'authorization_level_data' => 'getAuthorizationLevelData',
'authorization_permissions' => 'getAuthorizationPermissions',
'authorizations' => 'getAuthorizations',
'transfer' => 'getTransfer',
'scheduled_payment_permissions' => 'getScheduledPaymentPermissions',
'due_amount' => 'getDueAmount',
'installments' => 'getInstallments',
'recurring_payment_permissions' => 'getRecurringPaymentPermissions',
'next_occurrence_date' => 'getNextOccurrenceDate',
'occurrence_interval' => 'getOccurrenceInterval',
'occurrences_count' => 'getOccurrencesCount',
'occurrences' => 'getOccurrences',
'original_transfer' => 'getOriginalTransfer',
'chargeback_transfer' => 'getChargebackTransfer',
'payment_request_permissions' => 'getPaymentRequestPermissions',
'comments' => 'getComments',
'expiration_date' => 'getExpirationDate',
'change_expiration_date_comments' => 'getChangeExpirationDateComments',
'process_date' => 'getProcessDate',
'transaction' => 'getTransaction',
'sms_code' => 'getSmsCode',
'scheduled' => 'getScheduled',
'scheduling' => 'getScheduling',
'installments_count' => 'getInstallmentsCount',
'first_installment_is_immediate' => 'getFirstInstallmentIsImmediate',
'first_occurrence_is_immediate' => 'getFirstOccurrenceIsImmediate',
'to_principal_type' => 'getToPrincipalType',
'to_principal_value' => 'getToPrincipalValue',
'payer_principal' => 'getPayerPrincipal',
'cancel_url' => 'getCancelUrl',
'success_url' => 'getSuccessUrl',
'preview' => 'getPreview',
'users_which_can_add_to_contacts' => 'getUsersWhichCanAddToContacts',
'users_which_can_view_profile' => 'getUsersWhichCanViewProfile',
'authorization_type' => 'getAuthorizationType',
'scheduled_payment_status' => 'getScheduledPaymentStatus',
'recurring_payment_status' => 'getRecurringPaymentStatus',
'payment_request_status' => 'getPaymentRequestStatus',
'external_payment_status' => 'getExternalPaymentStatus',
'ticket_status' => 'getTicketStatus'    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return parent::attributeMap() + self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return parent::setters() + self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return parent::getters() + self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    


    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        parent::__construct($data);

        $this->container['channel'] = isset($data['channel']) ? $data['channel'] : null;
        $this->container['access_client'] = isset($data['access_client']) ? $data['access_client'] : null;
        $this->container['by'] = isset($data['by']) ? $data['by'] : null;
        $this->container['received_by'] = isset($data['received_by']) ? $data['received_by'] : null;
        $this->container['received'] = isset($data['received']) ? $data['received'] : null;
        $this->container['custom_values'] = isset($data['custom_values']) ? $data['custom_values'] : null;
        $this->container['confirmation_password_input'] = isset($data['confirmation_password_input']) ? $data['confirmation_password_input'] : null;
        $this->container['authorization_level_data'] = isset($data['authorization_level_data']) ? $data['authorization_level_data'] : null;
        $this->container['authorization_permissions'] = isset($data['authorization_permissions']) ? $data['authorization_permissions'] : null;
        $this->container['authorizations'] = isset($data['authorizations']) ? $data['authorizations'] : null;
        $this->container['transfer'] = isset($data['transfer']) ? $data['transfer'] : null;
        $this->container['scheduled_payment_permissions'] = isset($data['scheduled_payment_permissions']) ? $data['scheduled_payment_permissions'] : null;
        $this->container['due_amount'] = isset($data['due_amount']) ? $data['due_amount'] : null;
        $this->container['installments'] = isset($data['installments']) ? $data['installments'] : null;
        $this->container['recurring_payment_permissions'] = isset($data['recurring_payment_permissions']) ? $data['recurring_payment_permissions'] : null;
        $this->container['next_occurrence_date'] = isset($data['next_occurrence_date']) ? $data['next_occurrence_date'] : null;
        $this->container['occurrence_interval'] = isset($data['occurrence_interval']) ? $data['occurrence_interval'] : null;
        $this->container['occurrences_count'] = isset($data['occurrences_count']) ? $data['occurrences_count'] : null;
        $this->container['occurrences'] = isset($data['occurrences']) ? $data['occurrences'] : null;
        $this->container['original_transfer'] = isset($data['original_transfer']) ? $data['original_transfer'] : null;
        $this->container['chargeback_transfer'] = isset($data['chargeback_transfer']) ? $data['chargeback_transfer'] : null;
        $this->container['payment_request_permissions'] = isset($data['payment_request_permissions']) ? $data['payment_request_permissions'] : null;
        $this->container['comments'] = isset($data['comments']) ? $data['comments'] : null;
        $this->container['expiration_date'] = isset($data['expiration_date']) ? $data['expiration_date'] : null;
        $this->container['change_expiration_date_comments'] = isset($data['change_expiration_date_comments']) ? $data['change_expiration_date_comments'] : null;
        $this->container['process_date'] = isset($data['process_date']) ? $data['process_date'] : null;
        $this->container['transaction'] = isset($data['transaction']) ? $data['transaction'] : null;
        $this->container['sms_code'] = isset($data['sms_code']) ? $data['sms_code'] : null;
        $this->container['scheduled'] = isset($data['scheduled']) ? $data['scheduled'] : null;
        $this->container['scheduling'] = isset($data['scheduling']) ? $data['scheduling'] : null;
        $this->container['installments_count'] = isset($data['installments_count']) ? $data['installments_count'] : null;
        $this->container['first_installment_is_immediate'] = isset($data['first_installment_is_immediate']) ? $data['first_installment_is_immediate'] : null;
        $this->container['first_occurrence_is_immediate'] = isset($data['first_occurrence_is_immediate']) ? $data['first_occurrence_is_immediate'] : null;
        $this->container['to_principal_type'] = isset($data['to_principal_type']) ? $data['to_principal_type'] : null;
        $this->container['to_principal_value'] = isset($data['to_principal_value']) ? $data['to_principal_value'] : null;
        $this->container['payer_principal'] = isset($data['payer_principal']) ? $data['payer_principal'] : null;
        $this->container['cancel_url'] = isset($data['cancel_url']) ? $data['cancel_url'] : null;
        $this->container['success_url'] = isset($data['success_url']) ? $data['success_url'] : null;
        $this->container['preview'] = isset($data['preview']) ? $data['preview'] : null;
        $this->container['users_which_can_add_to_contacts'] = isset($data['users_which_can_add_to_contacts']) ? $data['users_which_can_add_to_contacts'] : null;
        $this->container['users_which_can_view_profile'] = isset($data['users_which_can_view_profile']) ? $data['users_which_can_view_profile'] : null;
        $this->container['authorization_type'] = isset($data['authorization_type']) ? $data['authorization_type'] : null;
        $this->container['scheduled_payment_status'] = isset($data['scheduled_payment_status']) ? $data['scheduled_payment_status'] : null;
        $this->container['recurring_payment_status'] = isset($data['recurring_payment_status']) ? $data['recurring_payment_status'] : null;
        $this->container['payment_request_status'] = isset($data['payment_request_status']) ? $data['payment_request_status'] : null;
        $this->container['external_payment_status'] = isset($data['external_payment_status']) ? $data['external_payment_status'] : null;
        $this->container['ticket_status'] = isset($data['ticket_status']) ? $data['ticket_status'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = parent::listInvalidProperties();

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets channel
     *
     * @return 
     */
    public function getChannel()
    {
        return $this->container['channel'];
    }

    /**
     * Sets channel
     *
     * @param  $channel The channel this transaction was performed on
     *
     * @return $this
     */
    public function setChannel($channel)
    {
        $this->container['channel'] = $channel;

        return $this;
    }

    /**
     * Gets access_client
     *
     * @return 
     */
    public function getAccessClient()
    {
        return $this->container['access_client'];
    }

    /**
     * Sets access_client
     *
     * @param  $access_client The access client in use when this transaction was performed
     *
     * @return $this
     */
    public function setAccessClient($access_client)
    {
        $this->container['access_client'] = $access_client;

        return $this;
    }

    /**
     * Gets by
     *
     * @return 
     */
    public function getBy()
    {
        return $this->container['by'];
    }

    /**
     * Sets by
     *
     * @param  $by The user that actually performed the action. May be different than the from, for example, an administrator can perform payments in behalf of other users
     *
     * @return $this
     */
    public function setBy($by)
    {
        $this->container['by'] = $by;

        return $this;
    }

    /**
     * Gets received_by
     *
     * @return 
     */
    public function getReceivedBy()
    {
        return $this->container['received_by'];
    }

    /**
     * Sets received_by
     *
     * @param  $received_by The operator that actually received the payment. Only available if some other user has paid directly to it or the operator has received the payment via POS.
     *
     * @return $this
     */
    public function setReceivedBy($received_by)
    {
        $this->container['received_by'] = $received_by;

        return $this;
    }

    /**
     * Gets received
     *
     * @return bool
     */
    public function getReceived()
    {
        return $this->container['received'];
    }

    /**
     * Sets received
     *
     * @param bool $received True if the payment was received vía POS.
     *
     * @return $this
     */
    public function setReceived($received)
    {
        $this->container['received'] = $received;

        return $this;
    }

    /**
     * Gets custom_values
     *
     * @return \Cyclos\Api\Model\CustomFieldValue[]
     */
    public function getCustomValues()
    {
        return $this->container['custom_values'];
    }

    /**
     * Sets custom_values
     *
     * @param \Cyclos\Api\Model\CustomFieldValue[] $custom_values The list of custom field values
     *
     * @return $this
     */
    public function setCustomValues($custom_values)
    {
        $this->container['custom_values'] = $custom_values;

        return $this;
    }

    /**
     * Gets confirmation_password_input
     *
     * @return 
     */
    public function getConfirmationPasswordInput()
    {
        return $this->container['confirmation_password_input'];
    }

    /**
     * Sets confirmation_password_input
     *
     * @param  $confirmation_password_input If a confirmation password is used, contains the definitions on how to request that password from the user. This confirmation password is required when performing sensible actions. Sometimes this is dynamic, for example, the confirmation might be configured to be used only once per session, or operations like payments may have a limit per day to be without confirmation (pinless).
     *
     * @return $this
     */
    public function setConfirmationPasswordInput($confirmation_password_input)
    {
        $this->container['confirmation_password_input'] = $confirmation_password_input;

        return $this;
    }

    /**
     * Gets authorization_level_data
     *
     * @return 
     */
    public function getAuthorizationLevelData()
    {
        return $this->container['authorization_level_data'];
    }

    /**
     * Sets authorization_level_data
     *
     * @param  $authorization_level_data Only returned if the `kind` is either `payment`, `scheduledPayment` or `recurringPayment` and the transaction is pending for authorization. Contains data related to the current autorization level that can be authorized / denied.
     *
     * @return $this
     */
    public function setAuthorizationLevelData($authorization_level_data)
    {
        $this->container['authorization_level_data'] = $authorization_level_data;

        return $this;
    }

    /**
     * Gets authorization_permissions
     *
     * @return 
     */
    public function getAuthorizationPermissions()
    {
        return $this->container['authorization_permissions'];
    }

    /**
     * Sets authorization_permissions
     *
     * @param  $authorization_permissions Permissions the authenticated user has over this payment regarding authorizations.
     *
     * @return $this
     */
    public function setAuthorizationPermissions($authorization_permissions)
    {
        $this->container['authorization_permissions'] = $authorization_permissions;

        return $this;
    }

    /**
     * Gets authorizations
     *
     * @return \Cyclos\Api\Model\TransactionAuthorization[]
     */
    public function getAuthorizations()
    {
        return $this->container['authorizations'];
    }

    /**
     * Sets authorizations
     *
     * @param \Cyclos\Api\Model\TransactionAuthorization[] $authorizations Contains the details of the authorizations this payment has (for the previous levels). To see the final status of the payment please check the `authorizationStatus` property.
     *
     * @return $this
     */
    public function setAuthorizations($authorizations)
    {
        $this->container['authorizations'] = $authorizations;

        return $this;
    }

    /**
     * Gets transfer
     *
     * @return 
     */
    public function getTransfer()
    {
        return $this->container['transfer'];
    }

    /**
     * Sets transfer
     *
     * @param  $transfer Only returned if the `kind` is `payment`. This is the transfer generated when the payment was processed. Will be null if the went through authorization and was not authorized. Only returned if this `TransactionView` is not already in a `TransactionView`.
     *
     * @return $this
     */
    public function setTransfer($transfer)
    {
        $this->container['transfer'] = $transfer;

        return $this;
    }

    /**
     * Gets scheduled_payment_permissions
     *
     * @return 
     */
    public function getScheduledPaymentPermissions()
    {
        return $this->container['scheduled_payment_permissions'];
    }

    /**
     * Sets scheduled_payment_permissions
     *
     * @param  $scheduled_payment_permissions Only returned if the `kind` is `scheduledPayment`. Permissions over the scheduled payment.
     *
     * @return $this
     */
    public function setScheduledPaymentPermissions($scheduled_payment_permissions)
    {
        $this->container['scheduled_payment_permissions'] = $scheduled_payment_permissions;

        return $this;
    }

    /**
     * Gets due_amount
     *
     * @return float
     */
    public function getDueAmount()
    {
        return $this->container['due_amount'];
    }

    /**
     * Sets due_amount
     *
     * @param float $due_amount Only returned if the `kind` is `scheduledPayment`. Means the amount that is still needs to be paid until the last installment.
     *
     * @return $this
     */
    public function setDueAmount($due_amount)
    {
        $this->container['due_amount'] = $due_amount;

        return $this;
    }

    /**
     * Gets installments
     *
     * @return \Cyclos\Api\Model\ScheduledPaymentInstallmentView[]
     */
    public function getInstallments()
    {
        return $this->container['installments'];
    }

    /**
     * Sets installments
     *
     * @param \Cyclos\Api\Model\ScheduledPaymentInstallmentView[] $installments Only returned if the `kind` is `scheduledPayment`. Contains the installment references.
     *
     * @return $this
     */
    public function setInstallments($installments)
    {
        $this->container['installments'] = $installments;

        return $this;
    }

    /**
     * Gets recurring_payment_permissions
     *
     * @return 
     */
    public function getRecurringPaymentPermissions()
    {
        return $this->container['recurring_payment_permissions'];
    }

    /**
     * Sets recurring_payment_permissions
     *
     * @param  $recurring_payment_permissions Only returned if the `kind` is `recurringPayment`. Permissions over the scheduled payment.
     *
     * @return $this
     */
    public function setRecurringPaymentPermissions($recurring_payment_permissions)
    {
        $this->container['recurring_payment_permissions'] = $recurring_payment_permissions;

        return $this;
    }

    /**
     * Gets next_occurrence_date
     *
     * @return \DateTime
     */
    public function getNextOccurrenceDate()
    {
        return $this->container['next_occurrence_date'];
    }

    /**
     * Sets next_occurrence_date
     *
     * @param \DateTime $next_occurrence_date Only returned if the `kind` is `recurringPayment`. The scheduled date for the next occurrence.
     *
     * @return $this
     */
    public function setNextOccurrenceDate($next_occurrence_date)
    {
        $this->container['next_occurrence_date'] = $next_occurrence_date;

        return $this;
    }

    /**
     * Gets occurrence_interval
     *
     * @return 
     */
    public function getOccurrenceInterval()
    {
        return $this->container['occurrence_interval'];
    }

    /**
     * Sets occurrence_interval
     *
     * @param  $occurrence_interval Only returned if the `kind` is `recurringPayment`. The interval between occurrences.
     *
     * @return $this
     */
    public function setOccurrenceInterval($occurrence_interval)
    {
        $this->container['occurrence_interval'] = $occurrence_interval;

        return $this;
    }

    /**
     * Gets occurrences_count
     *
     * @return int
     */
    public function getOccurrencesCount()
    {
        return $this->container['occurrences_count'];
    }

    /**
     * Sets occurrences_count
     *
     * @param int $occurrences_count Only returned if the `kind` is `recurringPayment`. The programmed number of occurrences. If not set, means the payment will be processed until manually canceled.
     *
     * @return $this
     */
    public function setOccurrencesCount($occurrences_count)
    {
        $this->container['occurrences_count'] = $occurrences_count;

        return $this;
    }

    /**
     * Gets occurrences
     *
     * @return \Cyclos\Api\Model\RecurringPaymentOccurrenceView[]
     */
    public function getOccurrences()
    {
        return $this->container['occurrences'];
    }

    /**
     * Sets occurrences
     *
     * @param \Cyclos\Api\Model\RecurringPaymentOccurrenceView[] $occurrences Only returned if the `kind` is `recurringPayment`. A list with all occurrences this payment has.
     *
     * @return $this
     */
    public function setOccurrences($occurrences)
    {
        $this->container['occurrences'] = $occurrences;

        return $this;
    }

    /**
     * Gets original_transfer
     *
     * @return 
     */
    public function getOriginalTransfer()
    {
        return $this->container['original_transfer'];
    }

    /**
     * Sets original_transfer
     *
     * @param  $original_transfer Only returned if the `kind` is `chargeback`. This is the original transfer that has been charged back.
     *
     * @return $this
     */
    public function setOriginalTransfer($original_transfer)
    {
        $this->container['original_transfer'] = $original_transfer;

        return $this;
    }

    /**
     * Gets chargeback_transfer
     *
     * @return 
     */
    public function getChargebackTransfer()
    {
        return $this->container['chargeback_transfer'];
    }

    /**
     * Sets chargeback_transfer
     *
     * @param  $chargeback_transfer Only returned if the `kind` is `chargeback`. This is the transfer which performed the chargeback.
     *
     * @return $this
     */
    public function setChargebackTransfer($chargeback_transfer)
    {
        $this->container['chargeback_transfer'] = $chargeback_transfer;

        return $this;
    }

    /**
     * Gets payment_request_permissions
     *
     * @return 
     */
    public function getPaymentRequestPermissions()
    {
        return $this->container['payment_request_permissions'];
    }

    /**
     * Sets payment_request_permissions
     *
     * @param  $payment_request_permissions Permissions the user has over this payment request.
     *
     * @return $this
     */
    public function setPaymentRequestPermissions($payment_request_permissions)
    {
        $this->container['payment_request_permissions'] = $payment_request_permissions;

        return $this;
    }

    /**
     * Gets comments
     *
     * @return string
     */
    public function getComments()
    {
        return $this->container['comments'];
    }

    /**
     * Sets comments
     *
     * @param string $comments Only returned if the `kind` is either `paymentRequest` or `externalPayment`. The comments the user informed when performing the payment.
     *
     * @return $this
     */
    public function setComments($comments)
    {
        $this->container['comments'] = $comments;

        return $this;
    }

    /**
     * Gets expiration_date
     *
     * @return \DateTime
     */
    public function getExpirationDate()
    {
        return $this->container['expiration_date'];
    }

    /**
     * Sets expiration_date
     *
     * @param \DateTime $expiration_date Only returned if the `kind` is either `paymentRequest`, `externalPayment` or `ticket`. The deadline for the payment to be processed.  In case of `externalPayment` if no user is registered with either e-mail or mobile phone matching, it is canceled. The same is done in case of `ticket` if it is not accepted by any user.
     *
     * @return $this
     */
    public function setExpirationDate($expiration_date)
    {
        $this->container['expiration_date'] = $expiration_date;

        return $this;
    }

    /**
     * Gets change_expiration_date_comments
     *
     * @return string
     */
    public function getChangeExpirationDateComments()
    {
        return $this->container['change_expiration_date_comments'];
    }

    /**
     * Sets change_expiration_date_comments
     *
     * @param string $change_expiration_date_comments Only returned if the `kind` is `paymentRequest`. The comments the user informed when changing the expiration date.
     *
     * @return $this
     */
    public function setChangeExpirationDateComments($change_expiration_date_comments)
    {
        $this->container['change_expiration_date_comments'] = $change_expiration_date_comments;

        return $this;
    }

    /**
     * Gets process_date
     *
     * @return \DateTime
     */
    public function getProcessDate()
    {
        return $this->container['process_date'];
    }

    /**
     * Sets process_date
     *
     * @param \DateTime $process_date Only returned if the `kind` is either `paymentRequest`, `ticket` or `externalPayment` and `status` is `processed`. The date the payment request / ticket was accepted.
     *
     * @return $this
     */
    public function setProcessDate($process_date)
    {
        $this->container['process_date'] = $process_date;

        return $this;
    }

    /**
     * Gets transaction
     *
     * @return 
     */
    public function getTransaction()
    {
        return $this->container['transaction'];
    }

    /**
     * Sets transaction
     *
     * @param  $transaction Only returned if the `kind` is `paymentRequest`, `ticket` or `externalPayment`  and `status` is `processed`. Reference to the transaction that was generated when processing this payment request / externalPayment / ticket.
     *
     * @return $this
     */
    public function setTransaction($transaction)
    {
        $this->container['transaction'] = $transaction;

        return $this;
    }

    /**
     * Gets sms_code
     *
     * @return string
     */
    public function getSmsCode()
    {
        return $this->container['sms_code'];
    }

    /**
     * Sets sms_code
     *
     * @param string $sms_code Only returned if the `kind` is either `paymentRequest` and `status` is not `processed`. The code that can be used by the receiver to confirm this payment request via SMS operation.
     *
     * @return $this
     */
    public function setSmsCode($sms_code)
    {
        $this->container['sms_code'] = $sms_code;

        return $this;
    }

    /**
     * Gets scheduled
     *
     * @return bool
     */
    public function getScheduled()
    {
        return $this->container['scheduled'];
    }

    /**
     * Sets scheduled
     *
     * @param bool $scheduled See the documentation of `scheduling` instead.   Only returned if the `kind` is `paymentRequest`. Indicates whether a scheduled payment (`true`)  will be generated once this payment request is confirmed.
     *
     * @return $this
     */
    public function setScheduled($scheduled)
    {
        $this->container['scheduled'] = $scheduled;

        return $this;
    }

    /**
     * Gets scheduling
     *
     * @return 
     */
    public function getScheduling()
    {
        return $this->container['scheduling'];
    }

    /**
     * Sets scheduling
     *
     * @param  $scheduling Only returned if the `kind` is `paymentRequest`. Indicates whether the generated payment will be a scheduled, recurring or regular payment once this payment request is confirmed.
     *
     * @return $this
     */
    public function setScheduling($scheduling)
    {
        $this->container['scheduling'] = $scheduling;

        return $this;
    }

    /**
     * Gets installments_count
     *
     * @return int
     */
    public function getInstallmentsCount()
    {
        return $this->container['installments_count'];
    }

    /**
     * Sets installments_count
     *
     * @param int $installments_count Only returned if the `kind` is `paymentRequest` and `scheduled` is `true`. Indicates the number of installments to be generated.
     *
     * @return $this
     */
    public function setInstallmentsCount($installments_count)
    {
        $this->container['installments_count'] = $installments_count;

        return $this;
    }

    /**
     * Gets first_installment_is_immediate
     *
     * @return bool
     */
    public function getFirstInstallmentIsImmediate()
    {
        return $this->container['first_installment_is_immediate'];
    }

    /**
     * Sets first_installment_is_immediate
     *
     * @param bool $first_installment_is_immediate Only returned if the `kind` is `paymentRequest` and `scheduled` is `true`. Indicates whether the first installment should be processed immediately when the payment request is confirmed.
     *
     * @return $this
     */
    public function setFirstInstallmentIsImmediate($first_installment_is_immediate)
    {
        $this->container['first_installment_is_immediate'] = $first_installment_is_immediate;

        return $this;
    }

    /**
     * Gets first_occurrence_is_immediate
     *
     * @return bool
     */
    public function getFirstOccurrenceIsImmediate()
    {
        return $this->container['first_occurrence_is_immediate'];
    }

    /**
     * Sets first_occurrence_is_immediate
     *
     * @param bool $first_occurrence_is_immediate Only returned if the `kind` is `paymentRequest` and `scheduling` is `recurring`. Indicates whether the first occurrence should be processed immediately when the payment request is confirmed.
     *
     * @return $this
     */
    public function setFirstOccurrenceIsImmediate($first_occurrence_is_immediate)
    {
        $this->container['first_occurrence_is_immediate'] = $first_occurrence_is_immediate;

        return $this;
    }

    /**
     * Gets to_principal_type
     *
     * @return 
     */
    public function getToPrincipalType()
    {
        return $this->container['to_principal_type'];
    }

    /**
     * Sets to_principal_type
     *
     * @param  $to_principal_type Only returned if the `kind` is `externalPayment`. Is the user identification method for this external payment (for example, e-mail or mobile phone).
     *
     * @return $this
     */
    public function setToPrincipalType($to_principal_type)
    {
        $this->container['to_principal_type'] = $to_principal_type;

        return $this;
    }

    /**
     * Gets to_principal_value
     *
     * @return string
     */
    public function getToPrincipalValue()
    {
        return $this->container['to_principal_value'];
    }

    /**
     * Sets to_principal_value
     *
     * @param string $to_principal_value Only returned if the `kind` is `externalPayment`. Is the user identification value for this external payment (for example, the e-mail or mobile phone values).
     *
     * @return $this
     */
    public function setToPrincipalValue($to_principal_value)
    {
        $this->container['to_principal_value'] = $to_principal_value;

        return $this;
    }

    /**
     * Gets payer_principal
     *
     * @return string
     */
    public function getPayerPrincipal()
    {
        return $this->container['payer_principal'];
    }

    /**
     * Sets payer_principal
     *
     * @param string $payer_principal Only returned if the `kind` is `ticket`, the ticket status is `open` and there is a fixed payer. Is the principal (for example, login name or e-mail) which can be used to login the user, so he can accept the ticket.
     *
     * @return $this
     */
    public function setPayerPrincipal($payer_principal)
    {
        $this->container['payer_principal'] = $payer_principal;

        return $this;
    }

    /**
     * Gets cancel_url
     *
     * @return string
     */
    public function getCancelUrl()
    {
        return $this->container['cancel_url'];
    }

    /**
     * Sets cancel_url
     *
     * @param string $cancel_url Only returned if the `kind` is `ticket`. The URL to redirect when canceling the ticket.
     *
     * @return $this
     */
    public function setCancelUrl($cancel_url)
    {
        $this->container['cancel_url'] = $cancel_url;

        return $this;
    }

    /**
     * Gets success_url
     *
     * @return string
     */
    public function getSuccessUrl()
    {
        return $this->container['success_url'];
    }

    /**
     * Sets success_url
     *
     * @param string $success_url Only returned if the `kind` is `ticket`. The URL to redirect after successfully accepting a ticket
     *
     * @return $this
     */
    public function setSuccessUrl($success_url)
    {
        $this->container['success_url'] = $success_url;

        return $this;
    }

    /**
     * Gets preview
     *
     * @return 
     */
    public function getPreview()
    {
        return $this->container['preview'];
    }

    /**
     * Sets preview
     *
     * @param  $preview Only returned if the `kind` is `ticket` and the ticket can be accepted. Is the payment preview if accepting the ticket. The preview will never contain a confirmation password input, because this object already contains it on the `confirmationPasswordInput` property, neither a payment to be sent back, as this payment is supposed to be confirmed by accepting the ticket. Also, the preview's currency is never sent, as it is the same one of the ticket.
     *
     * @return $this
     */
    public function setPreview($preview)
    {
        $this->container['preview'] = $preview;

        return $this;
    }

    /**
     * Gets users_which_can_add_to_contacts
     *
     * @return \Cyclos\Api\Model\TransactionSubjectsEnum
     */
    public function getUsersWhichCanAddToContacts()
    {
        return $this->container['users_which_can_add_to_contacts'];
    }

    /**
     * Sets users_which_can_add_to_contacts
     *
     * @param \Cyclos\Api\Model\TransactionSubjectsEnum $users_which_can_add_to_contacts users_which_can_add_to_contacts
     *
     * @return $this
     */
    public function setUsersWhichCanAddToContacts($users_which_can_add_to_contacts)
    {
        $this->container['users_which_can_add_to_contacts'] = $users_which_can_add_to_contacts;

        return $this;
    }

    /**
     * Gets users_which_can_view_profile
     *
     * @return \Cyclos\Api\Model\TransactionSubjectsEnum
     */
    public function getUsersWhichCanViewProfile()
    {
        return $this->container['users_which_can_view_profile'];
    }

    /**
     * Sets users_which_can_view_profile
     *
     * @param \Cyclos\Api\Model\TransactionSubjectsEnum $users_which_can_view_profile users_which_can_view_profile
     *
     * @return $this
     */
    public function setUsersWhichCanViewProfile($users_which_can_view_profile)
    {
        $this->container['users_which_can_view_profile'] = $users_which_can_view_profile;

        return $this;
    }

    /**
     * Gets authorization_type
     *
     * @return \Cyclos\Api\Model\TransactionAuthorizationTypeEnum
     */
    public function getAuthorizationType()
    {
        return $this->container['authorization_type'];
    }

    /**
     * Sets authorization_type
     *
     * @param \Cyclos\Api\Model\TransactionAuthorizationTypeEnum $authorization_type authorization_type
     *
     * @return $this
     */
    public function setAuthorizationType($authorization_type)
    {
        $this->container['authorization_type'] = $authorization_type;

        return $this;
    }

    /**
     * Gets scheduled_payment_status
     *
     * @return \Cyclos\Api\Model\ScheduledPaymentStatusEnum
     */
    public function getScheduledPaymentStatus()
    {
        return $this->container['scheduled_payment_status'];
    }

    /**
     * Sets scheduled_payment_status
     *
     * @param \Cyclos\Api\Model\ScheduledPaymentStatusEnum $scheduled_payment_status scheduled_payment_status
     *
     * @return $this
     */
    public function setScheduledPaymentStatus($scheduled_payment_status)
    {
        $this->container['scheduled_payment_status'] = $scheduled_payment_status;

        return $this;
    }

    /**
     * Gets recurring_payment_status
     *
     * @return \Cyclos\Api\Model\RecurringPaymentStatusEnum
     */
    public function getRecurringPaymentStatus()
    {
        return $this->container['recurring_payment_status'];
    }

    /**
     * Sets recurring_payment_status
     *
     * @param \Cyclos\Api\Model\RecurringPaymentStatusEnum $recurring_payment_status recurring_payment_status
     *
     * @return $this
     */
    public function setRecurringPaymentStatus($recurring_payment_status)
    {
        $this->container['recurring_payment_status'] = $recurring_payment_status;

        return $this;
    }

    /**
     * Gets payment_request_status
     *
     * @return \Cyclos\Api\Model\PaymentRequestStatusEnum
     */
    public function getPaymentRequestStatus()
    {
        return $this->container['payment_request_status'];
    }

    /**
     * Sets payment_request_status
     *
     * @param \Cyclos\Api\Model\PaymentRequestStatusEnum $payment_request_status payment_request_status
     *
     * @return $this
     */
    public function setPaymentRequestStatus($payment_request_status)
    {
        $this->container['payment_request_status'] = $payment_request_status;

        return $this;
    }

    /**
     * Gets external_payment_status
     *
     * @return \Cyclos\Api\Model\ExternalPaymentStatusEnum
     */
    public function getExternalPaymentStatus()
    {
        return $this->container['external_payment_status'];
    }

    /**
     * Sets external_payment_status
     *
     * @param \Cyclos\Api\Model\ExternalPaymentStatusEnum $external_payment_status external_payment_status
     *
     * @return $this
     */
    public function setExternalPaymentStatus($external_payment_status)
    {
        $this->container['external_payment_status'] = $external_payment_status;

        return $this;
    }

    /**
     * Gets ticket_status
     *
     * @return \Cyclos\Api\Model\TicketStatusEnum
     */
    public function getTicketStatus()
    {
        return $this->container['ticket_status'];
    }

    /**
     * Sets ticket_status
     *
     * @param \Cyclos\Api\Model\TicketStatusEnum $ticket_status ticket_status
     *
     * @return $this
     */
    public function setTicketStatus($ticket_status)
    {
        $this->container['ticket_status'] = $ticket_status;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}
