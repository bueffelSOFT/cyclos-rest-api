<?php
/**
 * PasswordInput
 *
 * PHP version 5
 *
 * @category Class
 * @package  Cyclos\Api
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Cyclos 4.12.6 API
 *
 * The Cyclos REST API is described using OpenAPI 3.0. The descriptor for the api can be downloaded in both [YAML](http://kb1.cyclos-dev.info/api/cyclos-openapi.yaml) or [JSON](http://kb1.cyclos-dev.info/api/cyclos-openapi.json) formats. These files can be used in tools that support the OpenAPI specification, such as the [Swagger Generator](https://generator.swagger.io/).  In the API, whenever some data is referenced, for example, a group, or payment type, either id or internal name can be used. When an user is to be referenced, the special word 'self' (sans quotes) always refers to the currently authenticated user, and any identification method (login name, e-mail, mobile phone, account number or custom field) that can be used on keywords search (as configured in the products) can also be used to identify users. Some specific data types have other identification fields, like accounts can have a number and payments can have a transaction number. This all depends on the current configuration.  Most of the operations that return data allow selecting which fields to include in the response. This is useful for reducing the data to be download over the network. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  For details of the deprecated elements (operations and model) please visit the [deprecation notes page](https://documentation.cyclos.org/4.12.6/api-deprecation.html) for this version.
 *
 * OpenAPI spec version: 4.12.6
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.19
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Cyclos\Api\Model;
use \Cyclos\Api\ObjectSerializer;

/**
 * PasswordInput Class Doc Comment
 *
 * @category Class
 * @description Contains all information for a password entry. Passwords in Cyclos may be entered as regular texts or as virtual keyboards. For &#x60;virtualKeyboard&#x60;, a number of information is sent, such as an unique id, the number of buttons to be displayed, the number of rows that should visually hold those buttons, the sequences of characters that should be displayed on each button. When sending the value of a password of type virtual keyboard, unique id should be sent, together with the entire sequence for each button, all separated by pipes. So, suppose a very simple (and weakly configured) example where the id is &#x60;987654321&#x60; and the sequences are: &#x60;[[\&quot;abc\&quot;, \&quot;def\&quot;, \&quot;fgh\&quot;], [\&quot;ijk\&quot;, \&quot;lmn\&quot;, \&quot;opq\&quot;]]&#x60;. This describes 2 sequences of 3 buttons each. First, the buttons with the options &#x60;abc&#x60;, &#x60;def&#x60; and &#x60;fgh&#x60; should be shown. Suppose the user chooses the second one. Then the button labels should be changed to &#x60;ijk&#x60;, &#x60;lmn&#x60; and &#x60;opq&#x60;. Now the user picks the first one. The value sent to the server should be &#x60;987654321|def|ijk&#x60;.
 * @package  Cyclos\Api
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class PasswordInput extends InternalNamedEntity 
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'PasswordInput';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'has_active_password' => 'bool',
'has_active_device' => 'bool',
'confirmation_password_once_per_session' => 'bool',
'min_length' => 'int',
'max_length' => 'int',
'number_of_buttons' => 'int',
'buttons_per_row' => 'int',
'buttons' => 'string[][]',
'input_method' => '',
'mode' => '\Cyclos\Api\Model\PasswordModeEnum',
'device_availability' => '',
'pin_availability' => '',
'pin_input' => '',
'otp_send_mediums' => '\Cyclos\Api\Model\SendMediumEnum[]'    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'has_active_password' => null,
'has_active_device' => null,
'confirmation_password_once_per_session' => null,
'min_length' => null,
'max_length' => null,
'number_of_buttons' => null,
'buttons_per_row' => null,
'buttons' => null,
'input_method' => null,
'mode' => null,
'device_availability' => null,
'pin_availability' => null,
'pin_input' => null,
'otp_send_mediums' => null    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes + parent::swaggerTypes();
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats + parent::swaggerFormats();
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'has_active_password' => 'hasActivePassword',
'has_active_device' => 'hasActiveDevice',
'confirmation_password_once_per_session' => 'confirmationPasswordOncePerSession',
'min_length' => 'minLength',
'max_length' => 'maxLength',
'number_of_buttons' => 'numberOfButtons',
'buttons_per_row' => 'buttonsPerRow',
'buttons' => 'buttons',
'input_method' => 'inputMethod',
'mode' => 'mode',
'device_availability' => 'deviceAvailability',
'pin_availability' => 'pinAvailability',
'pin_input' => 'pinInput',
'otp_send_mediums' => 'otpSendMediums'    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'has_active_password' => 'setHasActivePassword',
'has_active_device' => 'setHasActiveDevice',
'confirmation_password_once_per_session' => 'setConfirmationPasswordOncePerSession',
'min_length' => 'setMinLength',
'max_length' => 'setMaxLength',
'number_of_buttons' => 'setNumberOfButtons',
'buttons_per_row' => 'setButtonsPerRow',
'buttons' => 'setButtons',
'input_method' => 'setInputMethod',
'mode' => 'setMode',
'device_availability' => 'setDeviceAvailability',
'pin_availability' => 'setPinAvailability',
'pin_input' => 'setPinInput',
'otp_send_mediums' => 'setOtpSendMediums'    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'has_active_password' => 'getHasActivePassword',
'has_active_device' => 'getHasActiveDevice',
'confirmation_password_once_per_session' => 'getConfirmationPasswordOncePerSession',
'min_length' => 'getMinLength',
'max_length' => 'getMaxLength',
'number_of_buttons' => 'getNumberOfButtons',
'buttons_per_row' => 'getButtonsPerRow',
'buttons' => 'getButtons',
'input_method' => 'getInputMethod',
'mode' => 'getMode',
'device_availability' => 'getDeviceAvailability',
'pin_availability' => 'getPinAvailability',
'pin_input' => 'getPinInput',
'otp_send_mediums' => 'getOtpSendMediums'    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return parent::attributeMap() + self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return parent::setters() + self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return parent::getters() + self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    


    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        parent::__construct($data);

        $this->container['has_active_password'] = isset($data['has_active_password']) ? $data['has_active_password'] : null;
        $this->container['has_active_device'] = isset($data['has_active_device']) ? $data['has_active_device'] : null;
        $this->container['confirmation_password_once_per_session'] = isset($data['confirmation_password_once_per_session']) ? $data['confirmation_password_once_per_session'] : null;
        $this->container['min_length'] = isset($data['min_length']) ? $data['min_length'] : null;
        $this->container['max_length'] = isset($data['max_length']) ? $data['max_length'] : null;
        $this->container['number_of_buttons'] = isset($data['number_of_buttons']) ? $data['number_of_buttons'] : null;
        $this->container['buttons_per_row'] = isset($data['buttons_per_row']) ? $data['buttons_per_row'] : null;
        $this->container['buttons'] = isset($data['buttons']) ? $data['buttons'] : null;
        $this->container['input_method'] = isset($data['input_method']) ? $data['input_method'] : null;
        $this->container['mode'] = isset($data['mode']) ? $data['mode'] : null;
        $this->container['device_availability'] = isset($data['device_availability']) ? $data['device_availability'] : null;
        $this->container['pin_availability'] = isset($data['pin_availability']) ? $data['pin_availability'] : null;
        $this->container['pin_input'] = isset($data['pin_input']) ? $data['pin_input'] : null;
        $this->container['otp_send_mediums'] = isset($data['otp_send_mediums']) ? $data['otp_send_mediums'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = parent::listInvalidProperties();

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets has_active_password
     *
     * @return bool
     */
    public function getHasActivePassword()
    {
        return $this->container['has_active_password'];
    }

    /**
     * Sets has_active_password
     *
     * @param bool $has_active_password Only returned when there is an authenticated user (not for login). Describes whether the user has created a password of this type. If not, a proper message can be shown to the user indicating that this password needs to be created.
     *
     * @return $this
     */
    public function setHasActivePassword($has_active_password)
    {
        $this->container['has_active_password'] = $has_active_password;

        return $this;
    }

    /**
     * Gets has_active_device
     *
     * @return bool
     */
    public function getHasActiveDevice()
    {
        return $this->container['has_active_device'];
    }

    /**
     * Sets has_active_device
     *
     * @param bool $has_active_device Only returned when there is an authenticated user (not for login). Describes whether the user has at least one trusted device. If not, and the device confirmation is required a proper message can be shown to the user indicating that the user must activate a device as trusted.
     *
     * @return $this
     */
    public function setHasActiveDevice($has_active_device)
    {
        $this->container['has_active_device'] = $has_active_device;

        return $this;
    }

    /**
     * Gets confirmation_password_once_per_session
     *
     * @return bool
     */
    public function getConfirmationPasswordOncePerSession()
    {
        return $this->container['confirmation_password_once_per_session'];
    }

    /**
     * Sets confirmation_password_once_per_session
     *
     * @param bool $confirmation_password_once_per_session Only returned when there is an authenticated user (not for login). Determines whether this password, when used as confirmation, should be requested only once until the user logs out.
     *
     * @return $this
     */
    public function setConfirmationPasswordOncePerSession($confirmation_password_once_per_session)
    {
        $this->container['confirmation_password_once_per_session'] = $confirmation_password_once_per_session;

        return $this;
    }

    /**
     * Gets min_length
     *
     * @return int
     */
    public function getMinLength()
    {
        return $this->container['min_length'];
    }

    /**
     * Sets min_length
     *
     * @param int $min_length For text passwords, the minimum password length
     *
     * @return $this
     */
    public function setMinLength($min_length)
    {
        $this->container['min_length'] = $min_length;

        return $this;
    }

    /**
     * Gets max_length
     *
     * @return int
     */
    public function getMaxLength()
    {
        return $this->container['max_length'];
    }

    /**
     * Sets max_length
     *
     * @param int $max_length For text passwords, the maximum password length
     *
     * @return $this
     */
    public function setMaxLength($max_length)
    {
        $this->container['max_length'] = $max_length;

        return $this;
    }

    /**
     * Gets number_of_buttons
     *
     * @return int
     */
    public function getNumberOfButtons()
    {
        return $this->container['number_of_buttons'];
    }

    /**
     * Sets number_of_buttons
     *
     * @param int $number_of_buttons Only for `virtualKeyboard`, is the number of buttons to be displayed
     *
     * @return $this
     */
    public function setNumberOfButtons($number_of_buttons)
    {
        $this->container['number_of_buttons'] = $number_of_buttons;

        return $this;
    }

    /**
     * Gets buttons_per_row
     *
     * @return int
     */
    public function getButtonsPerRow()
    {
        return $this->container['buttons_per_row'];
    }

    /**
     * Sets buttons_per_row
     *
     * @param int $buttons_per_row Only for `virtualKeyboard`, is the number of buttons that should be displayed on each row
     *
     * @return $this
     */
    public function setButtonsPerRow($buttons_per_row)
    {
        $this->container['buttons_per_row'] = $buttons_per_row;

        return $this;
    }

    /**
     * Gets buttons
     *
     * @return string[][]
     */
    public function getButtons()
    {
        return $this->container['buttons'];
    }

    /**
     * Sets buttons
     *
     * @param string[][] $buttons Only for `virtualKeyboard`, contains the sequences of buttons that should be displayed for the user. The explanation for the value that should be sent on virtual keyboard mode is shown above, in the description of this type.
     *
     * @return $this
     */
    public function setButtons($buttons)
    {
        $this->container['buttons'] = $buttons;

        return $this;
    }

    /**
     * Gets input_method
     *
     * @return 
     */
    public function getInputMethod()
    {
        return $this->container['input_method'];
    }

    /**
     * Sets input_method
     *
     * @param  $input_method The explanation for the value that should be sent for `virtualKeyboard` cases is given above, in the description of this type.
     *
     * @return $this
     */
    public function setInputMethod($input_method)
    {
        $this->container['input_method'] = $input_method;

        return $this;
    }

    /**
     * Gets mode
     *
     * @return \Cyclos\Api\Model\PasswordModeEnum
     */
    public function getMode()
    {
        return $this->container['mode'];
    }

    /**
     * Sets mode
     *
     * @param \Cyclos\Api\Model\PasswordModeEnum $mode mode
     *
     * @return $this
     */
    public function setMode($mode)
    {
        $this->container['mode'] = $mode;

        return $this;
    }

    /**
     * Gets device_availability
     *
     * @return 
     */
    public function getDeviceAvailability()
    {
        return $this->container['device_availability'];
    }

    /**
     * Sets device_availability
     *
     * @param  $device_availability Whether the confirmation with a trusted device is not used, optional or required.
     *
     * @return $this
     */
    public function setDeviceAvailability($device_availability)
    {
        $this->container['device_availability'] = $device_availability;

        return $this;
    }

    /**
     * Gets pin_availability
     *
     * @return 
     */
    public function getPinAvailability()
    {
        return $this->container['pin_availability'];
    }

    /**
     * Sets pin_availability
     *
     * @param  $pin_availability Whether the confirmation with a device PIN is not used, optional or required.
     *
     * @return $this
     */
    public function setPinAvailability($pin_availability)
    {
        $this->container['pin_availability'] = $pin_availability;

        return $this;
    }

    /**
     * Gets pin_input
     *
     * @return 
     */
    public function getPinInput()
    {
        return $this->container['pin_input'];
    }

    /**
     * Sets pin_input
     *
     * @param  $pin_input The device PIN min length. Only if `pinAvailability` is not `disabled`
     *
     * @return $this
     */
    public function setPinInput($pin_input)
    {
        $this->container['pin_input'] = $pin_input;

        return $this;
    }

    /**
     * Gets otp_send_mediums
     *
     * @return \Cyclos\Api\Model\SendMediumEnum[]
     */
    public function getOtpSendMediums()
    {
        return $this->container['otp_send_mediums'];
    }

    /**
     * Sets otp_send_mediums
     *
     * @param \Cyclos\Api\Model\SendMediumEnum[] $otp_send_mediums Only for `otp`, the available mediums for the password to be sent
     *
     * @return $this
     */
    public function setOtpSendMediums($otp_send_mediums)
    {
        $this->container['otp_send_mediums'] = $otp_send_mediums;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}
